<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>analysis with igraph</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Fungal Networks</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="Multivariate.html">Multivariate analysis</a>
</li>
<li>
  <a href="analysis_igraph.html">Analysis with Igraph</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">analysis with igraph</h1>

</div>


<p>Check in igraph how to identify particular routes in a network</p>
<p>Think how to deal with the relationship between accessibility and resistance and route factor</p>
<pre class="r"><code>#To calcuate the second peak of the bimodal distribution
find_modes&lt;- function(x) {
  modes &lt;- NULL
  for ( i in 2:(length(x)-1) ){
    if ( (x[i] &gt; x[i-1]) &amp; (x[i] &gt; x[i+1]) ) {
      modes &lt;- c(modes,i)
    }
  }
  if ( length(modes) == 0 ) {
    modes = &#39;This is a monotonic distribution&#39;
  }
  return(modes)
}

trial&lt;-Edge_Traits$Width[Edge_Traits$name==&quot;C35(4)_t30&quot;]



my_mode_indices&lt;-
find_modes(density(trial)$y)


density(trial)$y[my_mode_indices]
density(trial)$x[my_mode_indices]
#0.9040683 5.5380611
density(trial)$x[which(density(trial)$y==max(density(trial)$y))]


#For all of them:
modes&lt;-function(x){
names(table(x))[table(x)==max(table(x))]}


tapply(Edge_Traits$Width, Edge_Traits$name, function(f) {density(f)$x[find_modes(density(f)$y)]})
tapply(Edge_Traits$Width, Edge_Traits$name,)



library(diptest)
plot(density(Edge_Traits$Width[Edge_Traits$name==&quot;C35(4)_t30&quot;]))
dip(Edge_Traits$Width[Edge_Traits$name==&quot;C35(4)_t30&quot;], full.result = T)
dip.test(Edge_Traits$Width[Edge_Traits$name==&quot;C35(4)_t30&quot;])



dip(trial,full.result = &quot;all&quot;)
plot(dip(trial,full.result = &quot;all&quot;))



data(&quot;statfaculty&quot;)
plot(density(statfaculty))
plot(dip(statfaculty,full.result = &quot;all&quot;))

#this package provides a metric of distances between the two means. However I do not really like it.
library(BimodalIndex)
library(oompaData)
data(lungData)
bimodalIndex(lung.dataset,verbose = F)
t(head(
Edge_Traits[Edge_Traits$name==&quot;C35(4)_t30&quot;,c(&quot;Width&quot;,&quot;Length&quot;)]))
bimodalIndex(t(Edge_Traits[Edge_Traits$name==&quot;C35(4)_t30&quot;,c(&quot;Width&quot;)]))

#The package &quot;multimode&quot; might also be useful

Re_org%&gt;%
        filter(variable %in% c(&quot;Width&quot;)) %&gt;% #,&quot;Length&quot;,&quot;Distance&quot;))%&gt;%#1_The completely indepedent variables
        filter(name==&quot;C35(4)_t30&quot;) %&gt;% 
        ggplot()+
        aes(value,fill=name)+
        #geom_histogram(binwidth = 0.5)+
        geom_density()+
        #facet_wrap(Species ~ variable, scales = &quot;free&quot;,nrow = 6,ncol = 3)+
        theme(legend.position = &quot;none&quot;)</code></pre>
<div id="as-a-conclussion-i-will-use-the-dip-statistic-to-describe-how-strong-is-the-bimodality-for-width-which-would-mean-how-distinct-are-the-major-roads-from-all-other-road-types." class="section level1">
<h1>As a conclussion I will use the Dip statistic to describe how “strong” is the bimodality for width, which would mean how distinct are the major roads from all other road types.</h1>
<p>For the multivariate analysis I should not use the mean for the width, but better the two modes, particularly the first peak which is the esiest to identify. For length I will use the log of the mean, for tortuosity as well, and for betweenness..</p>
</div>
<div id="understanding-betweeness" class="section level1">
<h1>Understanding betweeness</h1>
<p>The betwenness of edges (k=1) is not the same as the total number of edges</p>
<pre class="r"><code>tapply(Edge_Traits$name,Edge_Traits$name,length)

with(
  Edge_Traits[which(Edge_Traits$EndNodes_1_Degree==1|Edge_Traits$EndNodes_2_Degree==1),],
tapply(Betweenness,name,unique)
)</code></pre>
<p>But these two values are proportional to each other</p>
<pre class="r"><code>plot(
tapply(Edge_Traits$name,Edge_Traits$name,length),
with(
  Edge_Traits[which(Edge_Traits$EndNodes_1_Degree==1|Edge_Traits$EndNodes_2_Degree==1),],
tapply(Betweenness,name,unique)
)
)</code></pre>
<p>The edges maximum betweenness for each colony are located always close to the center of the colony</p>
<pre class="r"><code>tapply(Edge_Traits$Distance,Edge_Traits$name,min)</code></pre>
<pre class="r"><code>sapply(
  split(Edge_Traits,Edge_Traits$name),function(x){
    unique(x$Distance[x$Betweenness==max(x$Betweenness)])
  }
  
)

tapply(Edge_Traits$Betweenness,Edge_Traits$name,max)</code></pre>
<p>But they are not the minimal values, they lay though within 2 times the minimum distance</p>
<pre class="r"><code>sapply(
  split(Edge_Traits,Edge_Traits$name),function(x){
    summary(x$Betweenness[x$Distance&lt;=2*min(x$Distance)])
  }
  
)</code></pre>
<p>It makes sense for the maximum betweenness to lay close to the center of the colony as it is where most of the “root” edges are</p>
<p>The minimum betweenness value is 0 and it occurs in all colonies. Thus the question is, what do edges with betwenness 0 have in common?</p>
<ol style="list-style-type: lower-alpha">
<li>They are not tips. All of them have a degree larger or equal to two</li>
</ol>
<pre class="r"><code>with(
  Edge_Traits[which(Edge_Traits$Betweenness==0),],
tapply(EndNodes_2_Degree,name,summary)
)</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>They represent between the 6% to 14% of all edges</li>
</ol>
<pre class="r"><code>with(
  Edge_Traits[which(Edge_Traits$Betweenness==0),],
tapply(name,name,length)
)/tapply(Edge_Traits$name,Edge_Traits$name,length)</code></pre>
<pre class="r"><code>tapply(Edge_Traits$Distance,Edge_Traits$name,min)</code></pre>
<pre class="r"><code>sapply(
  split(Edge_Traits,Edge_Traits$name),function(x){
    summary(x$Distance[x$Betweenness&lt;=min(x$Betweenness)+10])
  }
  
)</code></pre>
<pre class="r"><code>temporal&lt;-Edge_Traits[which(Edge_Traits$Betweenness==
min(Edge_Traits$Betweenness)),]

Edge_Traits %&gt;% 
filter(Species==&quot;Mortierella elongata&quot;) %&gt;% 
  filter(Betweenness&lt;21729)%&gt;%
  ggplot()+
  aes(Betweenness)+
  geom_histogram()+
  facet_wrap(.~name)


Edge_Traits%&gt;%
#        filter(EndNodes_1_Degree==1|EndNodes_2_Degree==1)%&gt;%
  filter(Species==&quot;Mortierella elongata&quot;) %&gt;% 
  filter(Betweenness&gt;21729)%&gt;%
  
        select(c(&quot;name&quot;,&quot;Species&quot;,&quot;Width&quot;,&quot;Length&quot;,&quot;Area&quot;,&quot;Volume&quot;,&quot;Resistance_2ave&quot;,&quot;Tortuosity&quot;,&quot;Distance&quot;,
                 &quot;Accessibility&quot;,&quot;Betweenness&quot;,&quot;Route_factor&quot;,&quot;Or_ij&quot;))%&gt;%
        mutate(Log_Betweenness=log10(Betweenness+1))%&gt;%
        group_by(name)%&gt;%
        gather(key=variable,
            value=value,Width:Log_Betweenness)%&gt;%
        
        filter(variable %in% c(&quot;Betweenness&quot;))%&gt;%#4_Tortuosity has little variation and depends on Length
        ggplot()+
        aes(value,fill=name)+
        geom_histogram()+
  facet_wrap(name ~ variable, scales = &quot;free&quot;,nrow = 3,ncol = 3)#+
        #facet_wrap(Species ~ variable, scales = &quot;free&quot;,nrow = 6,ncol = 2)#+
        #theme(legend.position = &quot;none&quot;)</code></pre>
</div>
<div id="analyzing-the-graph-using-igraph" class="section level1">
<h1>Analyzing the graph using igraph</h1>
<pre class="r"><code>library(igraph)
library(tidyverse)</code></pre>
<p>igraph is versatile to analyze network properties. The first step is to create an igraph object from the edge list and node list tha comes out of Mark´s app</p>
<pre class="r"><code>Mucor_edge&lt;-read.csv(&quot;processedData\\DF56(6)_t09-Edge.csv&quot;,header = T, stringsAsFactors = F)#Node_Traits[which(Node_Traits$name==&quot;DF56(6)_t09&quot;),]
Mucor_node&lt;-read.csv(&quot;processedData\\DF56(6)_t09-Node.csv&quot;,header = T, stringsAsFactors = F,sep = &quot;;&quot;,dec = &quot;,&quot;)#Node_Traits[which(Node_Traits$name==&quot;DF56(6)_t09&quot;),]

edges_1&lt;-Mucor_edge[,c(&quot;EndNodes_1&quot;,&quot;EndNodes_2&quot;)]#Edge_Traits[which(Edge_Traits$name==&quot;DF56(6)_t09&quot;),c(&quot;EndNodes_1&quot;,&quot;EndNodes_2&quot;)]
edges_1&lt;-graph_from_edgelist(as.matrix(edges_1),directed = F)

spatial.data&lt;-Mucor_node[,#Node_Traits[which(Node_Traits$name==&quot;DF56(6)_t09&quot;),
                          c(&quot;node_ID&quot;,&quot;node_X_pix&quot;,&quot;node_Y_pix&quot;)]

l &lt;- as.matrix(spatial.data[,c(2,3)])
l &lt;- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)</code></pre>
<p>Visualizing the network via the igraph object</p>
<pre class="r"><code>plot(edges_1,
     edge.arrow.size=1,edge.curved=0,edge.width=2,
     edge.color=&quot;black&quot;, vertex.label=NA,vertex.shape=&quot;none&quot;,
     edge.size=150,vertex.size=0,layout=l*1,main=&quot;Real Network&quot;)</code></pre>
</div>
<div id="assigning-attributes-to-the-igraph-object" class="section level1">
<h1>Assigning attributes to the igraph object</h1>
<p>Attributes can be anything and can be name however I want to. Except for “weight” which will be used as the link weight</p>
<p>According to Mark´s manual these weights for hypha should be resistance</p>
<pre class="r"><code>E(edges_1)$weight&lt;-Mucor_edge$Resistance_2ave
#E(edges_1)$weight&lt;-Mucor_edge$Resistance_2
E(edges_1)$lenght&lt;-Mucor_edge$Length
E(edges_1)$width&lt;-Mucor_edge$Width</code></pre>
</div>
<div id="calculating-the-shortests-paths" class="section level1">
<h1>Calculating the shortests paths</h1>
<p>Now I calculate the shortests paths from the inoculum and to every other vertex. As specifed in Mark´s manual, the shortest path is the one that sums the lowest resistance (using Resistance_2ave). To do this, igrap has the function get.shortest.paths, which according to its documentation uses the same algorithm as reported in Mark´s manual, quoting: “By default igraph tries to select the fastest suitable algorithm. If there are no weights, then an unweighted breadth-first search is used, otherwise if all weights are positive, then Dijkstra’s algorithm is used.”</p>
<pre class="r"><code>#With this line one can check which number corresponds to the inoculum
Mucor_edge[which(Mucor_edge$Type==&quot;F&quot;),c(&quot;EndNodes_1&quot;,&quot;EndNodes_2&quot;)]

trial&lt;-get.shortest.paths(edges_1,from = 5279)</code></pre>
<p>Now I am trying to get the total length of those shortests paths. In principle these lenghts should be identical to the ones obtained by multiplying the node route factor with the node distance</p>
<pre class="r"><code>(Mucor_node$node_RF*Mucor_node$node_Distance)[1]</code></pre>
<p>I found two methods to do this:</p>
<p>Method 1</p>
<pre class="r"><code>sum(E(edges_1,path = trial$vpath[[1]])$lenght
    )</code></pre>
<p>Method 2</p>
<pre class="r"><code>sum(
E(induced.subgraph(edges_1,as_ids(trial$vpath[[1]])))$lenght
)</code></pre>
<p>Now calculating these lengths for all the network using method 1 and comparing with node_rf * node_distance</p>
<pre class="r"><code>route_lengths&lt;-rep(0,length(Mucor_node$node_RF))
for (i in 1:length(trial$vpath)) {
  route_lengths[i]&lt;-sum(E(edges_1,path = trial$vpath[[i]])$lenght
    
  )
}

plot(
  (Mucor_node$node_RF*Mucor_node$node_Distance),
  route_lengths
)</code></pre>
<p>Now calculating these lengths for all the network using method 2 and comparing with node_rf * node_distance</p>
<pre class="r"><code>route_lengths&lt;-rep(0,length(Mucor_node$node_RF))
for (i in 1:length(trial$vpath)) {
  route_lengths[i]&lt;-sum(E(induced.subgraph(edges_1,as_ids(trial$vpath[[i]])))$lenght
    
  )
}

plot(
  (Mucor_node$node_RF*Mucor_node$node_Distance),
  route_lengths
)</code></pre>
<p>I can also get node accessibility using igraph. For that I use the function distances and it does give me exactly the same values as in node_accessiblity coming from Mark´s app</p>
<pre class="r"><code>plot(
distances(edges_1,v=5279),#here each distance is the lowest summation of edge resistances from node 5279 to each other node
Mucor_node$node_Accessibility
)

temporal&lt;-distances(edges_1,v=5279)
summary(as.vector(temporal)/
as.vector(Mucor_node$node_Accessibility))</code></pre>
<p>These results confirm the following:</p>
<ul>
<li>igraph calculate distances based on hyphal resistance using the Dijkestra algorithm exactly in the same way as in Mark´s app. This means that accessibility to a node is simply the lowest summation of resistances of edges (a path) from the inoculum to that node. *But for some reason there is small discrepancy between the lengths calulation. I think that the culprit might be in the values of length themselves, but his would need to be checked.</li>
</ul>
<p>Now trying to calculate new stuff</p>
<p>Route width I had initially high hopes about measuring the average widths of the shortests paths</p>
<pre class="r"><code>E(edges_1)$width&lt;-Mucor_edge$Width

E(induced.subgraph(edges_1,as_ids(trial$vpath[[i]])))$width

max(Mucor_edge$Width)
min(Mucor_edge$Length)

tapply(Edge_Traits$Width,Edge_Traits$name,max)#This is weird the maximum is fixed at 5.6 regardless of the colony, and when I also analyze my close up, I also get 5.6 as max value (which particularly makes no sense)
tapply(Edge_Traits$Width,Edge_Traits$name,min)</code></pre>
<p>Here, what I am doing is selecting a particular “shortest” path based on their width. This means that one can select distincts parts of the mycelia for analysis.</p>
<pre class="r"><code>ecol&lt;-rep(&quot;black&quot;,ecount(edges_1))
ecol[
   E(edges_1,path = trial$vpath[[1]])[
      E(edges_1,path = trial$vpath[[1]])&gt;=0.7*
         E(edges_1,path = trial$vpath[[1]])$width]
   ]&lt;-&quot;orange&quot;

neighbors(edges_1,5279)
incident(edges_1,5279)

E(edges_1)$type&lt;-&quot;E&quot;
E(edges_1)[incident(edges_1,5279)]$type&lt;-&quot;F&quot;



max(E(edges_1)$lenght)

max(
E(edges_1)[
E(edges_1)$type==&quot;E&quot;]$lenght)

E(edges_1)[
E(edges_1)$lenght==max(
E(edges_1)[
E(edges_1)$type==&quot;E&quot;]$lenght)
]

ecol[
  E(edges_1)$lenght==max(
E(edges_1)[
E(edges_1)$type==&quot;E&quot;]$lenght)
   ]&lt;-&quot;red&quot;

ecol&lt;-rep(&quot;black&quot;,ecount(edges_1))

ecol[E(edges_1)[inc(V(edges_1)[degree==1])&amp;lenght&gt;200]
  ]&lt;-&quot;green&quot;

ecol[E(edges_1)[inc(V(edges_1)[degree==2])]
  ]&lt;-&quot;blue&quot;

ecol[E(edges_1)[inc(V(edges_1)[degree==3])]
  ]&lt;-&quot;red&quot;

ecol[E(edges_1)$type==&quot;F&quot;]&lt;-&quot;gray80&quot;

plot(edges_1,
     edge.arrow.size=1,edge.curved=0,edge.width=2,
     vertex.label=NA,vertex.shape=&quot;none&quot;,
     edge.color=ecol,
     edge.size=150,vertex.size=0,layout=l*1,main=&quot;Real Network&quot;)

plot(edges_1,
     edge.arrow.size=1,edge.curved=0,edge.width=2,
     vertex.label.cex=0.2,
     #vertex.shape=&quot;none&quot;,
     edge.color=ecol,
     edge.size=150,vertex.size=0,layout=l*1,main=&quot;Real Network&quot;)

plot(edges_1,
     vertex.label.color=&quot;black&quot;, vertex.label.cex=1,vertex.size=1,
     edge.color=ecol,layout=l)</code></pre>
</div>
<div id="descriptive-traits-to-have" class="section level1">
<h1>Descriptive traits to have</h1>
<p>Mean tip hyphal length</p>
</div>
<div id="can-i-calculate-these-variables-also-for-toy-networks-based-on-the-mycelia-network" class="section level1">
<h1>Can I calculate these variables also for “toy” networks based on the mycelia network</h1>
<p>It seems that for minimum spanning trees is possible</p>
<pre class="r"><code>#Minimum spanning tree: 
library(igraph)
edges_1_no_weights&lt;-edges_1


edges_1_no_weights&lt;-
delete_edge_attr(edges_1_no_weights,&quot;weight&quot;)



edges_1mst&lt;-mst(edges_1)
edges_1_no_weights_mst&lt;-mst(edges_1_no_weights)


E(edges_1mst)$weight
E(edges_1_no_weights_mst)$weight


length(E(edges_1))
length(E(edges_1mst))
length(E(edges_1_no_weights_mst))

plot(edges_1mst,
     edge.arrow.size=1,edge.curved=0,edge.width=2,
     edge.color=&quot;black&quot;, vertex.label=NA,vertex.shape=&quot;none&quot;,
     edge.size=150,vertex.size=0,layout=l*1,main=&quot;Minimum Spanning Tree&quot;)


plot(edges_1_no_weights_mst,
     edge.arrow.size=1,edge.curved=0,edge.width=2,
     edge.color=&quot;black&quot;, vertex.label=NA,vertex.shape=&quot;none&quot;,
     edge.size=150,vertex.size=0,layout=l*1,main=&quot;Minimum Spanning Tree no weights&quot;)</code></pre>
<pre class="r"><code>min(Mucor_edge$Length)
plot(Mucor_edge$Length,Mucor_edge$Width)</code></pre>
<p>The other ones seems it is more complicated because they are based on vertex positions. Thus maybe what I could do is to get those distance based graphs and based on those ones subset the weights from the real network</p>
<pre class="r"><code>library(igraph)
length(degree(edges_1))

V(edges_1)$degree&lt;-degree(edges_1)
V(edges_1)$distance&lt;-Mucor_node$node_Distance
E(edges_1)$distance&lt;-Mucor_edge$Distance

no_feature&lt;-
subgraph.edges(edges_1,E(edges_1)[type==&quot;E&quot;])

E(no_feature)$hyphae&lt;-&quot;main&quot;
E(no_feature)[inc(V(no_feature)[degree==1])]$hyphae&lt;-&quot;tip&quot;
#E(no_feature)[inc(V(no_feature)[degree==1])]$hyphae&lt;-&quot;tip&quot;

probando&lt;-rbind(
  
data.frame(degree=&quot;tip&quot;,Lengths=
E(no_feature)[hyphae==&quot;tip&quot;]$lenght,
Widths=E(no_feature)[hyphae==&quot;tip&quot;]$width,
Distance=E(no_feature)[hyphae==&quot;tip&quot;]$distance),

data.frame(degree=&quot;main&quot;,Lengths=
E(no_feature)[hyphae==&quot;main&quot;]$lenght,
Widths=E(no_feature)[hyphae==&quot;main&quot;]$width,
Distance=E(no_feature)[hyphae==&quot;main&quot;]$distance)#,

#data.frame(degree=&quot;three&quot;,Lengths=
#E(no_feature)[inc(V(no_feature)[degree==1])]$lenght),
)

table(probando$degree)

library(tidyverse)
library(igraph)

probando %&gt;% 
  filter(degree==&quot;main&quot;) %&gt;% 
  ggplot()+
  aes(Distance,Widths)+#It does not seem to be a relationship between widht and distances, meaning that certain hyphae remian thick all the way from the inoculum to the the tip
  geom_point()
  #aes(degree,Widths)+
  #geom_boxplot()


hist(probando$Widths[probando$degree==&quot;tip&quot;])</code></pre>
<p>From this plot it is clear that there is a difference in width between hyphae a the tips and main hyphae. But that is not the case for length, that keep constant along the mycelium. So as descriptive trait I will use each mean for width and a single mean for length</p>
<pre class="r"><code>hist(probando$Widths[probando$degree==&quot;main&quot;])</code></pre>
<pre class="r"><code>trial&lt;-get.shortest.paths(edges_1,from = 5279)</code></pre>
<p>Now I am trying to get the total length of those shortests paths. In principle these lenghts should be identical to the ones obtained by multiplying the node route factor with the node distance</p>
<pre class="r"><code>(Mucor_node$node_RF*Mucor_node$node_Distance)[1]</code></pre>
<p>I found two methods to do this:</p>
<p>Method 1</p>
<pre class="r"><code>sum(E(edges_1,path = trial$vpath[[1]])$lenght
    )</code></pre>
<p>Now calculating these lengths for all the network using method 1 and comparing with node_rf * node_distance</p>
<pre class="r"><code>route_lengths&lt;-rep(0,length(Mucor_node$node_RF))
for (i in 1:length(trial$vpath)) {
  route_lengths[i]&lt;-sum(E(edges_1,path = trial$vpath[[i]])$lenght
    
  )
}

plot(
  (Mucor_node$node_RF*Mucor_node$node_Distance),
  route_lengths
)</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
